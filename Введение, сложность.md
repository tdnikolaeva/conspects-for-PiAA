# Сложность

Сложность - мера роста.

#### Виды сложности:

* по операциям - ?? скорость роста числа операций при возрастании объема входных данных
* по времени - как количество операций, которые выполняются при работе алгоритма, связано с объёмом входных данных;
* по памяти - как количество памяти, которое нужно алгоритму, связано с размером входных данных.


### Сложность по времени

Чаще всего под анализом сложности алгоритма понимают исследование времени, необходимого для его выполнения.

Но одна и та же программа при одних и тех же входных данных на разных ПК будет выполняться разное время. Поэтому измерения не могут быть единицами времени (секунды и т.д.).  Т.е. физическое время выполнения алгоритма должно зависеть от количества выполняемых в алгоритме команд и времени их выполнения:

i*t, где
* i - число действий (элементарных операций, команд), элементарные операции – это операции, из которых складывается алгоритм решения задачи (:=, <>, =, +, –, *, /; and, or, not, xor; call, return)
* t - среднее время выполнения одного элементарного действия, зависит от скорости обработки сигналов ВМ.

Поэтому временная сложность (трудоемкость или вычислительная сложность алгоритма) определяется количеством элементарных операций, совершаемых алгоритмом для решения им поставленной задачи.

Временная сложность алгоритма (в худшем случае) - это функция размера входных и выходных данных, равная максимальному количеству элементарных операций, алгоритма.

Количество элементарных операций, зависит не только от размера входных данных, но и от самих данных (например, сортировка вставками, быстрее работает с уже отсортированными данными).

Если размер выхода не превосходит размер входа, то временную сложность можно рассматривать как функцию только размера входных данных.
T(N) - функция временной сложности (трудоемкости) - зависимость времени работы от количества входных данных N – размер задачи.

Однако:

* не всегда ясно, какие операции следует считать элементарными
* разные операции требуют для своего выполнения разного времени
* перевод операций алгоритма в операции, используемые в компьютере зависит от свойства компилятора и квалификации программиста и т.п.
* в ряде случаев неизвестна структура программы

Кроме того, точное значение количества операций, выполненных алгоритмом, не играет существенной роли в его анализе, т.к. не является качественным показателем эффективности алгоритма.

### Сложность по памяти

Под емкостной сложностью (пространственной сложностью, эффективностью) понимают объем памяти, требуемой для выполнения программы. Это функция размера входных и выходных данных.

Но память не является критическим ресурсом для современных ВМ.


### Сложность по операциям???

Скоростью роста сложности алгоритма называется скорость роста числа операций при возрастании объема входных данных.
Поэтому анализ сложности алгоритма предлагается осуществлять, исследуя как меняется время работы программы при увеличении объема входных данных (N) и с какой скоростью.

Вычислительная сложность алгоритмов по-разному зависит от входных данных:

* только от объема данных
* От значений данных 
* От порядка поступления данных 
* От всех перечисленных выше факторов

Например, многие алгоритмы сортировки потратят гораздо меньше времени на упорядочивание массива, если он уже отсортирован.

Обычно у задачи есть какой-нибудь естественный параметр, характеризующий объем входных данных, и сложность оценивается по отношению к этому параметру

## Понятие вычислительной сложности в зависимости от размера входа

Вычислительная сложность (алгоритмическая сложность) - понятие, обозначающее функцию зависимости объема работы алгоритма от размера обрабатываемых данных.
В качестве показателей вычислительной сложности алгоритма выступают:

* Временная сложность (время выполнения).

    Временная сложность алгоритма - это функция от размера входных данных, равная количеству элементарных операций, проделываемых алгоритмом для решения экземпляра задачи указанного размера. Временная сложность алгоритма зачастую может быть определена точно, однако в большинстве случаев искать точное ее значение бессмысленно, т.к. работа алгоритма зависит от ряда факторов, например, скорости процессора, набора его инструкций и т.д.

* Асимптотическая сложность.

    Асимптотическая сложность оценивает сложность работы алгоритма с использованием асимптотического анализа. Алгоритм с меньшей асимптотической сложностью является более эффективным для всех входных данных.

Ассимптотическая сложность описывается 

* O-нотацией - верхняя граница
* Омега-ноация - нижняя граница

Каждая оценка при этом может быть:

* наилучшая: минимальная временная оценка;
* наихудшая: максимальная временная оценка;
* средняя: средняя временная оценка.



## Константная сложность на примере vector и unordered_set????
**_!!!!Это есть еще в другом. Там именно с лекции Калишенко. Тут чат гпт_**

#### Вектор (vector):

* Константная сложность: доступ к элементу по индексу вектора имеет константную сложность O(1), так как вектор использует динамический массив для хранения элементов, и доступ к элементу по индексу выполняется за постоянное время.
* Амортизированная сложность: большинство операций вставки вектора имеют амортизированную сложность O(1), так как вставка в конец вектора обычно выполняется за O(1), но в некоторых случаях может потребоваться перевыделение памяти и копирование всех элементов, что увеличивает сложность до O(n).

#### unordered_set:

* Константная сложность: добавление, удаление и поиск элемента в unordered_set имеют константную сложность O(1) в среднем, так как они используют хеш-таблицу для хранения элементов, которая обеспечивает быстрый доступ к данным.
* Амортизированная сложность: в худшем случае операции вставки, удаления и поиска могут иметь сложность O(n), если все элементы попадают в одну корзину хеш-таблицы, что приводит к линейной сложности. В среднем же амортизированная сложность остается константной O(1) благодаря равномерному распределению элементов по корзинам.





## ИЗ КОНСПЕКТА
Существует несколько видов сложности алгоритмов, которые обычно используются для анализа
и оценки эффективности алгоритмов. Некоторые из наиболее распространенных видов сложности
включают:
1. Временная сложность (Time Complexity):
Это мера количества времени, необходимого для выполнения алгоритма в зависимости от размера входных данных. Оценка временной сложности позволяет предсказать, как будет изменяться время выполнения алгоритма при увеличении размера входных данных. Обычно время
работы алгоритма выражается в терминах "O-нотации"(Big O notation), которая описывает его
асимптотическое поведение при стремлении размера входных данных к бесконечности. Примеры временной сложности включают 𝑂(1) (константная сложность), 𝑂(𝑛) (линейная сложность),
𝑂(n^2
) (квадратичная сложность) и т. д.
2. Пространственная сложность (Space Complexity):
Пространственная сложность алгоритма определяет, сколько дополнительной памяти требуется для выполнения алгоритма в зависимости от размера входных данных. Она измеряется
в терминах объема памяти, необходимого для хранения структур данных и временных переменных во время выполнения алгоритма. Пространственная сложность также может быть
выражена в O-нотации, аналогично временной сложности.
3. Вычислительная сложность (Computational Complexity):
Вычислительная сложность алгоритма определяет количество вычислительных ресурсов, таких как операции с плавающей точкой, умножения, сравнения и другие, необходимых для
выполнения алгоритма. Эта сложность связана с конкретной аппаратной платформой и может
варьироваться в зависимости от реализации алгоритма.
4. Сложность по другим параметрам:
В зависимости от конкретной задачи или алгоритма могут быть определены и другие виды
сложности, специфичные для этой задачи. Например, в некоторых случаях может быть важной
оценка энергетической сложности алгоритма или сложности связи/коммуникации при параллельном выполнении.
#### Понятие вычислительной сложности в зависимости от размера входа
• Константный − 𝑇(𝑛) = 𝑂(1)
Любой алгортм, всегда требующий независимо от размера данных одного и того же времени,
имеет константную сложность.
Если не считать эффективность в наилучшем случае, в этот класс попадает небольшое число
алгоритмов.
34
• Логарифмический − 𝑇(𝑛) = 𝑂(log(𝑛))
Эффективность алгоритма логарифмическая. Алгоритм начинает работать намного медленее
с увеличением размера выходных данных (𝑛).
Такое время работы характерно для алгоритмов, в которых большая задача делится на маленькие, каждая из которых решается по отдельности.
• Линейный − 𝑇(𝑛) = 𝑂(𝑛)
Эффективность алгоритма меняется линейно в зависимости от размера входных данных (обычно такое наблюдается, когда каждый элемент входных данных требуется обработать линейное
число раз).
К этому классу относятся алгоритмы, выполняющие сканирование списка, состоящего из 𝑛
элементов (Например, алгоритм поиска методом последовательного перебора).
• Линейно-логарифмический − 𝑇(𝑛) = 𝑂(𝑛 log(𝑛))
Такая эффективность характерна для алгоритмов, которые делят большую проблему на маленькие, а затем, решив их, соединяют их решения.
К этому классу относятся большое количество алгоритмов декомпозиции, таких как алгоритмы
сортировки, быстрого преобразования Фурье.
• Квадратичный − 𝑇(𝑛) = 𝑂(n^2
)
Обычно, подобная зависимость характеризует эффективность алгоритма, содержищих два встроенных цикла (Например, ряд операций, выполняемых над матрицами размера 𝑛 × 𝑛).
• Кубический − 𝑇(𝑛) = 𝑂(n^3
)
Обычно, подобная зависимость характеризует эффективность алгоритма, содержищих три встроенных цикла.
• Экспоненциальный − 𝑇(𝑛) = 𝑂(2^n
)
Данная зависимость типична для алгоритмов, выполняющих обработку всех подмножеств некоторого 𝑛-элементного множества.
Часто термин "экспоненциальный"применятся в широком смысле и означает очень высокий
порядок роста (аргумент Big-O).
• Факториальный − 𝑇(𝑛) = 𝑂(𝑛!)
Характеризует алгоритмы, выполняющих обработку всех перестановок некотрого 𝑛-элементного
множества.

